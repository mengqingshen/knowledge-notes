---
title: 4 继承
categories:
  - Objective-C基础教程第二版
---

>**说明：**处理类和对象的关系时，要重视`OOP`的两个方面
>+ **继承：**定义一个具有父类所有功能的新类
>+ **复合：**在对象中引用其他对象

## 4.1 为何使用继承
>**说明：**将所有重复的内容合并在一起，并在需要的地方拥有自定义的方法。
>**不使用继承的架构**
>![Alt text](http://cdn.mengqingshen.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-02%20%E4%B8%8B%E5%8D%887.34.10.png)
>**使用继承后的架构**
>![Alt text](http://cdn.mengqingshen.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-02%20%E4%B8%8B%E5%8D%887.35.04.png)

## 4.2 继承的语法格式
>**说明：**`@interface 子类名: 父类名`

|术语|说明|
|-|-|
|超类（或父类）|继承的类|
|子类（或孩子类）|执行继承的类|
|重写|如果想改变方法的实现，需要重写继承的方法|

>**注意：**`O-C`不支持多继承（可以使用类别和协议模拟多继承效果）

## 4.3 继承的工作机制

### 4.3.1 方法调度
>**说明：**当发送消息时，`O-C`的方法调度机制将在当前的类中搜索相应的方法。如果无法在接收消息的对象的类文件中找到相应的方法，它就会在该对象的超类中进行查找。
>**注意：**如果在最顶层的`NSObject`类中也没有找到该方法，则会出现一个运行时错误。

### 4.3.2 实例变量
>**说明：**`O-C` 中图和访问实例变量
>+ 子类会从父类继承实例变量
>+ 子类根据自己的情况添加额外的自己的实例变量
>+ 每个方法被调用时都获得了一个名为`self`的参数，`self`指向继承链中第一个类中的第一个实例变量。

>**多态性：**使用更具体种类的对象来代替一般类型，这种能力被称为`多态性`。
>**扩展：**通过`对象基地址`（第一个实例变量的首个字节在内存中的位置）加上`偏移地址`，编译器就可以查找其他实例变量的位置。这个机制叫做`基地址加偏移`，通过硬编码实现，但存在`脆弱的基类问题`，`Leopard`系统中通过引入64位`Objective-C`运行时（使用间接寻址方式确定变量的位置）解决了这个问题。

## 4.4 重写方法

### super关键字
>**说明：**利用`super`，既可以重写方法的实现，又能调用超类中的实现方式。
>**原理：**既不是参数也不是实例变量，而是由`Objective-C`编译器提供的一种神奇的功能。当想`super`发送消息时，实际上是在请求`Obective-C`向该类的超类发送消息。如果超类中没有定义该消息，则向平常一样继续在`继承链`上一级中查找。

## 4.5 小结

## 4.6 举个栗子

```objective-c

```


